<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Let&#x27;s Talk About Clean Code | Path Undefined</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&family=Noto+Serif:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/main.css">
  <link rel="stylesheet" href="/github.min.css">
</head>

<body>
  <div class="site">
    <header class="header">
      <div class="site-title">
        Path Undefined
      </div>
      <div class="one-sentence">
        — An undefined path of life.
      </div>

      <nav class="nav">
        <ul class="nav__list">
          <li class="nav__item">
            <a class="nav__link" href="/">
              Newest
            </a>
          </li>
          <li class="nav__item">
            <a class="nav__link" href="/archive.html">
              Archive
            </a>
          </li>
        </ul>
      </nav>
    </header>

    <hr class="splitter" />

    <main class="main">
      <article>
  <h1>Let&#39;s Talk About Clean Code</h1>
<p>There is a very interesting phnomenon in the IT-industry. You wrote a piece of code, which you thought is deadly simple, intuitive and easy to be understood, and then you committed it, pushed it, and then you got the feedback from experienced developers saying that &quot;it is not clean&quot;, because &quot;you are repeating yourself, it is not DRY&quot; or &quot;it is the best practise to do this this and that but you are not doing it&quot;.</p>
<p>It seems that those &quot;rules&quot; and &quot;best practises&quot; are objective. As a junior developer, it&#39;s your duty to follow these objective rules.</p>
<p>In my humble opinion, this couldn&#39;t me more wrong. Each and every project, technology, environment, team, management, even the history of the project are different, how can we say there is one rule ruling them all?</p>
<p>I learnt programming since I was a child. I was aware of clean code not because I had read the book, neither because I had been told to do so, but rather because I found my code is not comprehensive anymore after 2 weeks of development. That&#39;s why at that time I was already aware of the basic motivation of clean code. The project should grow without taking a disadvantage of &quot;I cannot understand it anymore&quot; or &quot;I cannot change it anymore&quot; in the future, and this is still my goal nowadays behind the persuing of &quot;clean code&quot;.</p>
<p>But if those &quot;rules&quot; and &quot;best practises&quot; are becoming a set of &quot;golden rules&quot; or &quot;silver bullets&quot;, do they still have this motivation behind them? </p>
<p>I don&#39;t think so.</p>
<p>I have seen so many code bases, they follow a same pattern. Abstract layer over abstract layer and methods calling after methods calling. You want to change the code to fix a bug? Your are welcome to modify over 20 files, and there is no garantee that you won&#39;t cause side effects, even though the test coverage is 98%. And I know exactly, someone has persued the rule of &quot;Don&#39;t Repeat Yourself&quot; too much.</p>
<p>DRY itself has a good intention behind it, it urges people to think about abstraction of the structure. But it has been clearly overdone. There are 2 different types of repititions. One is the repitition on the surface, which means the different pieces of code looks exactly the same; and another one is the repitition of the intention, which means the different pieces of code serves the same goal (even if they don&#39;t look the same). Which part should we get rid of? For me it is clearly the second part. Because that is exactly the motivation why we want to make the abstraction. But if we are just extracting code because they &quot;look the same&quot;, then:</p>
<ol>
<li>it is not intuitive for the reader;</li>
<li>it is very likely, that one instance of the repitition is going to change alone, and what should we do now? We could:<ul>
<li>change the abstracted part to support more different situations, then as the time goes, the abstraction will have to support thousands of different situations, which makes the code base bloated and hard to be understood;</li>
<li>change the single instance not to use the abstraction, then why we extract the code at the first place?</li>
</ul>
</li>
</ol>
<p>This is only one typical examples that I have faced in the industry, but there are more. There are too many actually, there are too many people just following the rules instead of thinking about what is the motivation behind it.</p>
<p>So many people are waving those words like &quot;KISS&quot;, &quot;DRY&quot;, &quot;SRP&quot;, &quot;Open-Close&quot; like weapons to crusify the heretics, which makes me feel so tired. Not because these principles are wrong, but rather to crusify a colleague at workplace is probably the last thing that the author of those principles have ever thought about.</p>
<p>To me, the best lesson that I have ever had about clean code is not being taught by a developer, but by a manager. I asked him about the situation in the company, while explaining, he has used a lot of words like interface, module and all other IT related terms. It has inspired me, because that was the first time that I have realised, actually to manage the code is just like managing a company. Probably managing code is even easier, because code doesn&#39;t play office politics.</p>
<p>Inspired by the idea to build the relationship between company management and programming, with a decade experience of writing code. I have summarized all those priciples into 4 simple considerations, which I have to do before writing clean code:</p>
<ol>
<li>be clear, which part of the code (which department) is doing what, and how to make different modules of the code (different departments) communicate with each other efficiently;</li>
<li>be specific, how a task has been done (company processes), describe it in an easy way to be understood;</li>
<li>be aware, the programmer (the process designer) who wrote the code (company process) is not the only one who needs to understand the code, because the code is not only for execution but also for communication;</li>
<li>be open, different people have different way of thinking, discuss with logic and facts for the best solution for the situation.</li>
</ol>
<p>According to this set of considerations, would you establish a &quot;document stamping department&quot;, just because there is a stamp on each of the documents that the company sends out? This is actually exactly the problem that I have seen behind the source code where DRY has been overly done though.</p>
<p>I really hope the people in the IT-industry could be more pragmatic instead of dogmatic.</p>

</article>
    </main>

    <hr class="splitter" />

    <footer class="footer">
      <p class="footer__copyright">
        ©2025 Path Undefined. All Rights Reserved.
      </p>
    </footer>
  </div>
</body>

</html>
